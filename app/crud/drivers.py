# drivers.py
# CRUD operations for the Driver model in the database.

from sqlalchemy import select, delete               # For building SQL SELECT and DELETE statements
from sqlalchemy.ext.asyncio import AsyncSession     # Async session for non-blocking DB access
from fastapi import HTTPException                   # For raising HTTP errors in API layers
from app.models.drivers import Driver               # The SQLAlchemy ORM model for drivers

async def getDriverByCard(session: AsyncSession, card: str):
    """
    Retrieve a single Driver by their RFID card ID.
    Returns the Driver instance or None if not found.
    """
    result = await session.execute(
        select(Driver).filter(Driver.card == card)
    )
    return result.scalars().first()

async def createDriver(session: AsyncSession, driver_data):
    """
    Create a new Driver record.
    - Checks for existing card to avoid duplicates.
    - On conflict, raises 400 Bad Request.
    - On success, commits and returns the new Driver.
    """
    # Prevent duplicate cards
    existing = await getDriverByCard(session, driver_data.card)
    if existing:
        raise HTTPException(
            status_code=400,
            detail="Autista con questa card già esistente"
        )

    # Instantiate and persist
    new_driver = Driver(**driver_data.dict())
    session.add(new_driver)
    await session.commit()
    await session.refresh(new_driver)  # Load autogenerated fields (e.g. ID)
    return new_driver

async def deleteDriverByCard(session: AsyncSession, card: str) -> bool:
    """
    Delete a Driver by their card ID.
    Returns True if a row was deleted, False otherwise.
    """
    result = await session.execute(
        delete(Driver).where(Driver.card == card)
    )
    await session.commit()
    return result.rowcount > 0

async def updateDriver(session: AsyncSession, card: str, driver_data):
    """
    Update an existing Driver’s fields.
    - Validates that the original card exists.
    - If changing the card ID, ensures the new card is not already used.
    - Applies all fields from the input schema and commits.
    - Returns the updated Driver.
    """
    driver = await getDriverByCard(session, card)
    if not driver:
        raise HTTPException(status_code=404, detail="Autista non trovato")

    # If the card ID itself is being changed, check uniqueness
    if driver_data.card != card:
        existing = await getDriverByCard(session, driver_data.card)
        if existing:
            raise HTTPException(
                status_code=400,
                detail="Nuova card già in uso"
            )

    # Apply all updatable fields
    for key, value in driver_data.dict().items():
        setattr(driver, key, value)

    await session.commit()
    await session.refresh(driver)
    return driver

async def searchDrivers(session: AsyncSession, filters: dict):
    """
    Search for drivers matching optional filter criteria.
    Supported filters: card, company, driver_full_name,
    request_pin flag, request_vehicle_id flag.
    Returns a list of matching Driver instances.
    """
    query = select(Driver)

    # Apply text filters using case-insensitive LIKE
    if filters.get('card'):
        query = query.where(Driver.card.ilike(f"%{filters['card']}%"))
    if filters.get('company'):
        query = query.where(Driver.company.ilike(f"%{filters['company']}%"))
    if filters.get('driver_full_name'):
        query = query.where(Driver.driver_full_name.ilike(f"%{filters['driver_full_name']}%"))

    # Apply boolean filters directly
    if filters.get('request_pin') is not None:
        query = query.where(Driver.request_pin == filters['request_pin'])
    if filters.get('request_vehicle_id') is not None:
        query = query.where(Driver.request_vehicle_id == filters['request_vehicle_id'])

    result = await session.execute(query)
    return result.scalars().all()

